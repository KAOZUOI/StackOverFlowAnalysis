#include <algorithm>#include <array>#include <iostream>#include <set>#include <stack>#include <vector>int main() {    // comparison to sort the set naturally on inserting elements    const auto compare = [](const std::array<int, 2> &lhs,                            const std::array<int, 2> &rhs) {        return lhs[1] < rhs[1] || (lhs[1] == rhs[1] && lhs[0] < rhs[0]);    };    // set to maintain unique elements as it is used for lookup to check if we have visited the node already    std::set<std::array<int, 2>, decltype(compare)> exploredSet(compare);    // std::set<std::array<int, 2>> exploredSet;    int W;    int H;    int X;    int Y;    // std::vector<std::vector<int>> picture;    std::cin >> W;    std::cin >> H;    std::cin >> X;    std::cin >> Y;    int picture[W][H];    for (int i = 0; i < H; i++) {        for (int j = 0; j < W; j++) {            std::cin >> picture[i][j];        }    }    int color = picture[Y][X];    std::stack<std::array<int, 2>> toExploreStack;    toExploreStack.push({X, Y});    while (!toExploreStack.empty()) {        std::array<int, 2> point = toExploreStack.top();        toExploreStack.pop();        int px = point[0];        int py = point[1];        bool execute = true;        // plain for loop was slow, this method is fast        if (exploredSet.count(point) == 1) {            execute = false;        }        if (execute) {            exploredSet.insert(point);            if (px > 0 && picture[py][px - 1] == color) {                toExploreStack.push({px - 1, py});            }            if (px < (W - 1) && picture[py][px + 1] == color) {                toExploreStack.push({px + 1, py});            }            if (py > 0 && picture[py - 1][px] == color) {                toExploreStack.push({px, py - 1});            }            if (py < (H - 1) && picture[py + 1][px] == color) {                toExploreStack.push({px, py + 1});            }        }    }    for (std::array<int, 2> v : exploredSet) {        std::cout << v[0] << &quot; &quot; << v[1] << std::endl;    }}