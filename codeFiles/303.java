@Configuration@EnableConfigurationProperties(Props::class)@ConditionalOnProperty(prefix = Props.PROPERTY_PREFIX, name = [&quot;securityEnabled&quot;])@ConditionalOnWebApplication(type = SERVLET)open class ActuatorSecurityAutoConfiguration(private val props: Props) {@Bean@ConditionalOnMissingBean(PasswordEncoder::class)public open fun passwordEncoder(): PasswordEncoder {    return BCryptPasswordEncoder()}@Bean@ConditionalOnBean(UserDetailsService::class)public open fun actuatorUserDetailsManager(passwordEncoder: PasswordEncoder,                                           userDetailsManager: UserDetailsManager): UserDetailsManager {    userDetailsManager.createUser(            User.withUsername(props.username)                    .password(props.password)                    .passwordEncoder(passwordEncoder::encode)                    .roles(ACTUATOR_USER_ROLE)                    .build())        return userDetailsManager}@Bean@ConditionalOnMissingBean(UserDetailsService::class)public open fun defaultActuatorUserDetailsManager(passwordEncoder: PasswordEncoder): UserDetailsManager {    return InMemoryUserDetailsManager(listOf(            User.withUsername(props.username)                    .password(props.password)                    .passwordEncoder(passwordEncoder::encode)                    .roles(ACTUATOR_USER_ROLE)                    .build()    ))}@Bean@Throws(Exception::class)@Order(100) //the order is not respected as this is loaded after the main config classpublic open fun actuatorSecurityFilterChain(httpSecurity: HttpSecurity): SecurityFilterChain {    httpSecurity            .antMatcher(&quot;/actuator/**&quot;)            .authorizeHttpRequests {                it.antMatchers(&quot;/actuator/info&quot;, &quot;/actuator/health&quot;).permitAll()                        .antMatchers(HttpMethod.OPTIONS).permitAll()                        .anyRequest().hasRole(ACTUATOR_USER_ROLE)            }            .headers().disable()            .csrf().disable()            .httpBasic()    return httpSecurity.build()}