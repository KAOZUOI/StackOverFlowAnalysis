import org.bouncycastle.crypto.CryptoException;import org.bouncycastle.crypto.Signer;import org.bouncycastle.crypto.digests.SHA256Digest;import org.bouncycastle.crypto.params.AsymmetricKeyParameter;import org.bouncycastle.crypto.signers.RSADigestSigner;import org.bouncycastle.crypto.util.PrivateKeyFactory;import org.bouncycastle.util.encoders.Base64;import java.io.IOException;import java.nio.charset.StandardCharsets;import java.security.KeyFactory;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import java.security.PrivateKey;import java.security.spec.InvalidKeySpecException;import java.security.spec.PKCS8EncodedKeySpec;import java.time.Instant;import java.util.Arrays;import java.util.List;import java.util.Map;/** * // https://github.com/eBay/digital-signature-java-sdk/blob/main/src/main/java/com/ebay/developer/SignatureService.java * // https://github.com/eBay/digital-signature-java-sdk * */public class SignatureService {    private static final List<String> SIGNATURE_PARAMS = Arrays.asList(&quot;content-digest&quot;, &quot;x-ebay-signature-key&quot;, &quot;@method&quot;, &quot;@path&quot;, &quot;@authority&quot;);    public static final String CONTENT_DIGEST = &quot;content-digest&quot;;    public static final String SIGNATURE_PREFIX = &quot;sig1=:&quot;;    public static final String SIGNATURE_INPUT_PREFIX = &quot;sig1=&quot;;    public void sign(HttpRequest request, PrivateKeys privateKeys) {        request.usingHeader(&quot;x-ebay-signature-key&quot;, privateKeys.getJwe());        if(HttpMethodName.POST.equals(request.getHttpMethod())            || HttpMethodName.PUT.equals(request.getHttpMethod())){            String contentDigest = generateContentDigest(request.getPayload().getData(), &quot;SHA-256&quot;);            request.usingHeader(&quot;Content-Digest&quot;, contentDigest);        }        String signature = getSignature(request, privateKeys);        request.usingHeader(&quot;Signature&quot;, signature);        request.usingHeader(&quot;Signature-Input&quot;, SIGNATURE_INPUT_PREFIX + getSignatureInput());        request.usingHeader(&quot;x-ebay-enforce-signature&quot;, &quot;true&quot;);    }    /**     * Generate Content Digest     *     * @param body request body     * @param cipher ciper to use SHA-256 or SHA-512     * @return contentDigest content digest     */    private String generateContentDigest(String body, String cipher){        if(StringUtil.nullOrEmpty(body)){            return null;        }        String contentDigest = &quot;&quot;;        try {            MessageDigest messageDigest = MessageDigest                    .getInstance(cipher.toUpperCase());            String digest = new String(Base64.encode(                    messageDigest.digest(body.getBytes(StandardCharsets.UTF_8))));            if (StringUtil.nonNullNonEmpty(digest)) {                contentDigest = cipher + &quot;=:&quot; +                        digest + &quot;:&quot;;            }        } catch (Exception ex) {            throw new RuntimeException(                    &quot;Error generating Content-Digest header: &quot; + ex.getMessage(),                    ex);        }        return contentDigest;    }    /**     * Get 'Signature' header value     *     * @return signature signature     */    private String getSignature(HttpRequest httpRequest, PrivateKeys privateKeys){        try {            String baseString = calculateBase(httpRequest);            System.out.println(baseString);            byte[] base = baseString.getBytes(StandardCharsets.UTF_8);            Signer signer = new RSADigestSigner(new SHA256Digest());            AsymmetricKeyParameter privateKeyParameters = PrivateKeyFactory                    .createKey(getPrivateKey(privateKeys.getPrivateKey()).getEncoded());            signer.init(true, privateKeyParameters);            signer.update(base, 0, base.length);            byte[] signature = signer.generateSignature();            String signatureStr = new String(Base64.encode(signature));            return SIGNATURE_PREFIX + signatureStr +                    &quot;:&quot;;        } catch (CryptoException | IOException ex) {            throw new RuntimeException(                    &quot;Error creating value for signature: &quot; + ex.getMessage(), ex);        }    }    /**     * Method to calculate base string value     *     * @return calculatedBase base string     */    private String calculateBase(HttpRequest httpRequest){        Map<String, String> headers = httpRequest.getHeaders();        try {            StringBuilder buf = new StringBuilder();            for (String header : SIGNATURE_PARAMS) {                if (header.equalsIgnoreCase(CONTENT_DIGEST)                        && headers.get(CONTENT_DIGEST) == null) {                    continue;                }                buf.append(&quot;\&quot;&quot;);                buf.append(header.toLowerCase());                buf.append(&quot;\&quot;: &quot;);                if (header.startsWith(&quot;@&quot;)) {                    switch (header.toLowerCase()) {                        case &quot;@method&quot;:                            buf.append(httpRequest.getHttpMethod().toString().toUpperCase());                            break;                        case &quot;@authority&quot;:                            buf.append(httpRequest.getEndPoint().toString().replace(&quot;https://&quot;, &quot;&quot;).replace(&quot;/&quot;, &quot;&quot;));                            break;                        case &quot;@target-uri&quot;:                            buf.append(headers.get(&quot;@target-uri&quot;));                            break;                        case &quot;@path&quot;:                            buf.append(httpRequest.getResourcePath());                            break;                        case &quot;@scheme&quot;:                            buf.append(httpRequest.getAbsoluteURI().getScheme());                            break;                        case &quot;@request-target&quot;:                            buf.append(headers.get(&quot;@request-target&quot;));                            break;                        default:                            throw new RuntimeException(&quot;Unknown pseudo header &quot; + header);                    }                } else {                    if (!headers.containsKey(header)) {                        throw new RuntimeException(&quot;Header &quot; + header + &quot; not included in message&quot;);                    }                    buf.append(headers.get(header));                }                buf.append(&quot;\n&quot;);            }            buf.append(&quot;\&quot;@signature-params\&quot;: &quot;);            buf.append(getSignatureInput());            return buf.toString();        } catch (Exception ex) {            throw new RuntimeException(&quot;Error calculating signature base: &quot; + ex.getMessage(), ex);        }    }    /**     * Generate Signature Input header     *     * @return signatureInputHeader     */    private String getSignatureInput() {        StringBuilder signatureInputBuf = new StringBuilder();        signatureInputBuf.append(&quot;(&quot;);        for (int i = 0; i < SIGNATURE_PARAMS.size(); i++) {            String param = SIGNATURE_PARAMS.get(i);            if(param.equalsIgnoreCase(CONTENT_DIGEST)){                continue;            }            signatureInputBuf.append(&quot;\&quot;&quot;);            signatureInputBuf.append(param);            signatureInputBuf.append(&quot;\&quot;&quot;);            if (i < SIGNATURE_PARAMS.size() - 1) {                signatureInputBuf.append(&quot; &quot;);            }        }        signatureInputBuf.append(&quot;);created=&quot;);        signatureInputBuf.append(Instant.now().getEpochSecond());        return signatureInputBuf.toString();    }    /**     * Get private key value as a file or as a string value     *     * @return privateKey private key     */    public PrivateKey getPrivateKey(String privateKeyString) {        byte[] clear = Base64.decode(privateKeyString.getBytes());        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(clear);        try {            KeyFactory fact = KeyFactory.getInstance(&quot;RSA&quot;);            return fact.generatePrivate(keySpec);        } catch (NoSuchAlgorithmException e) {            throw new RuntimeException(e);        } catch (InvalidKeySpecException e) {            throw new RuntimeException(e);        }    }}