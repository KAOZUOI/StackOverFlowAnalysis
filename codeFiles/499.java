import java.util.Optional;import org.apache.flink.table.api.DataTypes;import org.apache.flink.table.catalog.DataTypeFactory;import org.apache.flink.table.functions.AggregateFunction;import org.apache.flink.table.types.DataType;import org.apache.flink.table.types.inference.InputTypeStrategies;import org.apache.flink.table.types.inference.TypeInference;import org.apache.flink.types.Row;public final class IValueAggregation extends AggregateFunction<Row, IValueAccumulator> {              @Override    public Row getValue(IValueAccumulator accumulator) {        return Row.of(accumulator.value);    }    @Override    public IValueAccumulator createAccumulator() {        return new IValueAccumulator();    }     /**     * Declares the {@link TypeInference} of this function. It specifies:     *     * <ul>     *   <li>which argument types are supported when calling this function,     *   <li>which {@link DataType#getConversionClass()} should be used when calling the JVM method     *       {@link #accumulate(Accumulator, Object, LocalDate)} during runtime,     *   <li>a similar strategy how to derive an accumulator type,     *   <li>and a similar strategy how to derive the output type.     * </ul>     */    @Override    public TypeInference getTypeInference(DataTypeFactory typeFactory) {        return TypeInference.newBuilder()                // accept a signature (ANY, DATE) both with default conversion classes,                // the input type strategy is mostly used to produce nicer validation exceptions                // during planning, implementers can decide to skip it if they are fine with failing                // at a later stage during code generation when the runtime method is checked                .inputTypeStrategy(                        InputTypeStrategies.sequence(                                InputTypeStrategies.explicit(DataTypes.FLOAT())))                // let the accumulator data type depend on the first input argument                .accumulatorTypeStrategy(                        callContext -> {                            //final DataType argDataType = callContext.getArgumentDataTypes().get(0);                            final DataType accDataType =                                    DataTypes.STRUCTURED(                                        IValueAccumulator.class,                                            DataTypes.FIELD(&quot;value&quot;, DataTypes.FLOAT()));                            return Optional.of(accDataType);                        })                // let the output data type depend on the first input argument                .outputTypeStrategy(                        callContext -> {                            //final DataType argDataType = callContext.getArgumentDataTypes().get(0);                            final DataType outputDataType =                                    DataTypes.ROW(                                            DataTypes.FIELD(&quot;value&quot;, DataTypes.FLOAT()));                            return Optional.of(outputDataType);                        })                .build();    }    public void accumulate(IValueAccumulator accumulator, Float signal_value) {                accumulator.value += signal_value;    }    public void resetAccumulator(IValueAccumulator accumulator) {        accumulator.value = 0.0F;    }    }