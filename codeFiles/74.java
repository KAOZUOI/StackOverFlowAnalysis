public class MyAsyncProcessor {    enum States {        Idle,        Read,        Write    }    ExecutorService pool;    private Map<Integer, States> socketStates = new HashMap<>();    public MyAsyncProcessor() {    }    public static void main(String[] args) throws IOException {        new MyAsyncProcessor().process();    }    public void process() throws IOException {        pool = Executors.newFixedThreadPool(2);        InetAddress host = InetAddress.getByName(&quot;localhost&quot;);        Selector selector = Selector.open();        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();        serverSocketChannel.configureBlocking(false);        serverSocketChannel.bind(new InetSocketAddress(host, 9876));        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);        SelectionKey key;        while (true) {            if (selector.select() > 0) {                Set<SelectionKey> selectedKeys = selector.selectedKeys();                Iterator<SelectionKey> i = selectedKeys.iterator();                while (i.hasNext()) {                    key = i.next();                    i.remove();                    MyTask task = new MyTask();                    if (key.isAcceptable()) {                        SocketChannel socketChannel = serverSocketChannel.accept();                        socketChannel.configureBlocking(false);                        System.out.println(&quot;Channel hashCode: &quot; + socketChannel.hashCode());                        socketChannel.register(selector, SelectionKey.OP_READ + SelectionKey.OP_WRITE);                        socketStates.put(socketChannel.hashCode(), States.Idle);                        System.out.println(&quot;Connection accepted from: &quot; + socketChannel.getLocalAddress());                    }                    if (key.isReadable()) {                        System.out.println(&quot;Readable&quot;);                        SocketChannel socketChannel = (SocketChannel) key.channel();                        States socketState = socketStates.get(socketChannel.hashCode());                        if (socketState == States.Idle) {                            socketStates.put(socketChannel.hashCode(), States.Read);                            ByteBuffer byteBuffer = ByteBuffer.allocate(1024);                            try {                                socketChannel.read(byteBuffer);                                String result = new String(byteBuffer.array()).trim();                                String[] words = result.split(&quot; &quot;);                                int secondsToRead = Integer.parseInt(words[words.length - 2])*1000;                                int secondsToWrite = Integer.parseInt(words[words.length - 1])*1000;                                task.setTimeToRead(secondsToRead);                                task.setTimeToWrite(secondsToWrite);                                System.out.println(task.getTimeToRead() + &quot; &quot; + task.getTimeToWrite());                                Runnable h = new MyAsyncReadThread(task);                                pool.execute(h);                                socketChannel.register(selector, SelectionKey.OP_WRITE);                            } catch (Exception e) {                                System.out.println(&quot;Closing Connection Read...&quot;);                            }                        }                    }                    if (key.isWritable()) {                        System.out.println(&quot;Writable&quot;);                        SocketChannel socketChannel = (SocketChannel) key.channel();                        States socketState = socketStates.get(socketChannel.hashCode());                        if (socketState == States.Read) {                            socketStates.put(socketChannel.hashCode(), States.Write);                            System.out.println(task.getTimeToRead() + &quot; &quot; + task.getTimeToWrite());                            Runnable h = new MyAsyncWriteThread(task);                            pool.execute(h);                        }                        key.cancel();                    }                }            }        }    }}